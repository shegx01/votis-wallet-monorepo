defmodule BeVotisWalletWeb.LoginControllerTest do
  use BeVotisWalletWeb.ConnCase, async: false

  import Mox

  alias BeVotisWallet.HTTPClient.Mock

  # Make sure mocks are verified when the test exits
  setup :verify_on_exit!

  # Set up the mock context
  setup do
    BeVotisWallet.Test.Mocks.setup_mocks()
    :ok
  end

  describe "POST /private/login" do
    test "successfully authenticates passkey user with valid stamped request", %{conn: conn} do
      # Create a user in the database
      user = insert(:user, %{email: "passkey@example.com", sub_org_id: "test_org_123"})

      # Mock successful passkey login response
      passkey_response = %{
        "activity" => %{
          "id" => "activity_passkey_123",
          "status" => "ACTIVITY_STATUS_COMPLETED",
          "type" => "ACTIVITY_TYPE_STAMP_LOGIN",
          "organizationId" => user.sub_org_id,
          "timestampMs" => "1746736509954",
          "result" => %{
            "activity" => %{
              "id" => "nested_activity_123",
              "organizationId" => user.sub_org_id,
              "status" => "ACTIVITY_STATUS_COMPLETED",
              "type" => "ACTIVITY_TYPE_STAMP_LOGIN",
              "intent" => %{
                "stampLoginIntent" => %{
                  "publicKey" => "test_public_key",
                  "expirationSeconds" => "900",
                  "invalidateExisting" => false
                }
              },
              "result" => %{
                "stampLoginResult" => %{
                  "session" => "passkey_jwt_token_xyz"
                }
              }
            }
          }
        }
      }

      # Set up Turnkey client mock for passkey authentication
      stub(Mock, :build_payload, fn method, url, headers, body ->
        assert method == :post
        assert String.contains?(url, "/public/v1/submit/stamp_login")

        # Verify passkey signature headers
        assert Enum.any?(headers, fn
                 {"X-Stamp-WebAuthn", _} -> true
                 _ -> false
               end)

        %{method: method, url: url, headers: headers, body: body}
      end)

      stub(Mock, :request, fn _payload ->
        {:ok, passkey_response}
      end)

      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "passkey",
          "email" => user.email,
          "stamped_body" => "stamped_passkey_request_body",
          "stamp" => "passkey_signature_12345"
        })

      response = json_response(conn, 200)
      assert %{"jwt" => "passkey_jwt_token_xyz"} = response
    end

    test "successfully authenticates oauth user with valid stamped request", %{conn: conn} do
      # Create a user in the database
      user = insert(:user, %{sub_org_id: "test_org_456"})

      # Mock successful OAuth login response
      oauth_response = %{
        "activity" => %{
          "id" => "activity_oauth_456",
          "status" => "ACTIVITY_STATUS_COMPLETED",
          "type" => "ACTIVITY_TYPE_OAUTH_LOGIN",
          "organizationId" => user.sub_org_id,
          "timestampMs" => "1746736509954",
          "result" => %{
            "activity" => %{
              "id" => "nested_activity_456",
              "organizationId" => user.sub_org_id,
              "status" => "ACTIVITY_STATUS_COMPLETED",
              "type" => "ACTIVITY_TYPE_OAUTH_LOGIN",
              "intent" => %{
                "oauthLoginIntent" => %{
                  "oidcToken" => "google_oidc_token",
                  "publicKey" => "oauth_public_key",
                  "expirationSeconds" => "900",
                  "invalidateExisting" => false
                }
              },
              "result" => %{
                "oauthLoginResult" => %{
                  "session" => "oauth_jwt_token_abc"
                }
              }
            }
          }
        }
      }

      # Set up Turnkey client mock for OAuth authentication
      stub(Mock, :build_payload, fn method, url, headers, body ->
        assert method == :post
        assert String.contains?(url, "/public/v1/submit/oauth_login")

        %{method: method, url: url, headers: headers, body: body}
      end)

      stub(Mock, :request, fn _payload ->
        {:ok, oauth_response}
      end)

      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "oauth",
          "org_id" => Base.encode64(user.sub_org_id),
          "stamped_body" => "stamped_oauth_request_body",
          "stamp" => "oauth_signature_67890"
        })

      response = json_response(conn, 200)
      assert %{"jwt" => "oauth_jwt_token_abc"} = response
    end

    test "handles organization with non-base64 encoded org_id", %{conn: conn} do
      # Create a user with a direct org_id (not base64 encoded)
      insert(:user, %{sub_org_id: "direct_org_789"})

      # Mock successful response
      passkey_response = %{
        "activity" => %{
          "id" => "activity_123",
          "result" => %{
            "activity" => %{
              "result" => %{
                "stampLoginResult" => %{
                  "session" => "direct_jwt_token"
                }
              }
            }
          }
        }
      }

      stub(Mock, :build_payload, fn _method, _url, _headers, _body ->
        %{method: :post, url: "test", headers: [], body: ""}
      end)

      stub(Mock, :request, fn _payload ->
        {:ok, passkey_response}
      end)

      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "passkey",
          # Not base64 encoded
          "org_id" => "direct_org_789",
          "stamped_body" => "stamped_request",
          "stamp" => "signature"
        })

      response = json_response(conn, 200)
      assert %{"jwt" => "direct_jwt_token"} = response
    end

    test "returns 400 for missing required parameters", %{conn: base_conn} do
      test_cases = [
        %{
          params: %{
            # missing auth_type
            "org_id" => "test_org",
            "stamped_body" => "body",
            "stamp" => "stamp"
          },
          expected_field: "auth_type"
        },
        %{
          params: %{
            "auth_type" => "passkey"
            # missing org_id, stamped_body, stamp
          },
          expected_field: "org_id"
        },
        %{
          params: %{
            "auth_type" => "passkey",
            "org_id" => "test_org"
            # missing stamped_body, stamp
          },
          expected_field: "stamped_body"
        },
        %{
          params: %{
            "auth_type" => "passkey",
            "org_id" => "test_org",
            "stamped_body" => "body"
            # missing stamp
          },
          expected_field: "stamp"
        }
      ]

      for %{params: params, expected_field: field} <- test_cases do
        conn = post(base_conn, ~p"/private/login", params)

        response = json_response(conn, 400)
        assert %{"error" => "Invalid parameters", "errors" => errors} = response
        assert Map.has_key?(errors, field)
      end
    end

    test "returns 400 for invalid auth_type", %{conn: conn} do
      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "invalid",
          "org_id" => "test_org",
          "stamped_body" => "body",
          "stamp" => "stamp"
        })

      response = json_response(conn, 400)

      assert %{"error" => "Invalid parameters", "errors" => %{"auth_type" => [error_msg]}} =
               response

      assert String.contains?(error_msg, "must be 'passkey' or 'oauth'")
    end

    test "returns 400 for empty required parameters", %{conn: conn} do
      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "passkey",
          "org_id" => "",
          "stamped_body" => "body",
          "stamp" => "stamp"
        })

      response = json_response(conn, 400)
      assert %{"error" => "Invalid parameters", "errors" => %{"org_id" => [error_msg]}} = response
      assert String.contains?(error_msg, "can't be blank")
    end

    test "returns 400 for non-binary stamped_body", %{conn: conn} do
      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "passkey",
          "org_id" => "test_org",
          # Not a binary
          "stamped_body" => 12345,
          "stamp" => "stamp"
        })

      response = json_response(conn, 400)

      assert %{"error" => "Invalid parameters", "errors" => %{"stamped_body" => error_msgs}} =
               response

      # When cast to :binary field fails, we get both "is required" and "is invalid" errors
      assert "is required" in error_msgs or "must be a non-empty binary" in error_msgs
    end

    test "returns 404 for non-existent organization", %{conn: conn} do
      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "passkey",
          "org_id" => "non_existent_org",
          "stamped_body" => "body",
          "stamp" => "stamp"
        })

      response = json_response(conn, 404)

      assert %{
               "error" => "Organization not found",
               "message" => "The specified organization does not exist"
             } = response
    end

    test "returns 404 for base64 encoded non-existent organization", %{conn: conn} do
      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "passkey",
          "org_id" => Base.encode64("non_existent_org"),
          "stamped_body" => "body",
          "stamp" => "stamp"
        })

      response = json_response(conn, 404)

      assert %{
               "error" => "Organization not found",
               "message" => "The specified organization does not exist"
             } = response
    end

    test "returns 401 for Turnkey authentication failure", %{conn: conn} do
      user = insert(:user, %{sub_org_id: "test_org_auth_fail"})

      # Mock Turnkey authentication failure
      stub(Mock, :build_payload, fn _method, _url, _headers, _body ->
        %{method: :post, url: "test", headers: [], body: ""}
      end)

      stub(Mock, :request, fn _payload ->
        {:error, 401, %{"message" => "Invalid signature"}}
      end)

      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "passkey",
          "org_id" => Base.encode64(user.sub_org_id),
          "stamped_body" => "invalid_body",
          "stamp" => "invalid_stamp"
        })

      response = json_response(conn, 401)

      assert %{
               "error" => "Authentication failed",
               "message" => "Invalid credentials or authentication service error"
             } = response
    end

    test "returns 400 for Turnkey bad request", %{conn: conn} do
      user = insert(:user, %{sub_org_id: "test_org_bad_request"})

      # Mock Turnkey bad request
      stub(Mock, :build_payload, fn _method, _url, _headers, _body ->
        %{method: :post, url: "test", headers: [], body: ""}
      end)

      stub(Mock, :request, fn _payload ->
        {:error, 400, %{"message" => "Malformed request"}}
      end)

      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "oauth",
          "org_id" => Base.encode64(user.sub_org_id),
          "stamped_body" => "malformed_body",
          "stamp" => "stamp"
        })

      response = json_response(conn, 400)
      assert %{"error" => "Authentication failed"} = response
    end

    test "handles non-standard Turnkey response structure gracefully", %{conn: conn} do
      user = insert(:user, %{sub_org_id: "test_org_custom"})

      # Mock non-standard response structure
      custom_response = %{
        "activity" => %{
          "id" => "activity_custom",
          "result" => %{
            "customResult" => %{
              "token" => "custom_session_token"
            }
          }
        }
      }

      stub(Mock, :build_payload, fn _method, _url, _headers, _body ->
        %{method: :post, url: "test", headers: [], body: ""}
      end)

      stub(Mock, :request, fn _payload ->
        {:ok, custom_response}
      end)

      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "passkey",
          "org_id" => Base.encode64(user.sub_org_id),
          "stamped_body" => "custom_body",
          "stamp" => "custom_stamp"
        })

      response = json_response(conn, 200)
      # Should fallback to JSON encoding of the custom result
      assert %{"jwt" => jwt} = response
      assert is_binary(jwt)
      # Verify it contains the custom result data
      assert String.contains?(jwt, "customResult")
    end

    test "handles completely unexpected response structure", %{conn: conn} do
      user = insert(:user, %{sub_org_id: "test_org_unexpected"})

      # Mock completely unexpected response
      unexpected_response = %{
        "unexpected" => "structure",
        "data" => %{"some" => "value"}
      }

      stub(Mock, :build_payload, fn _method, _url, _headers, _body ->
        %{method: :post, url: "test", headers: [], body: ""}
      end)

      stub(Mock, :request, fn _payload ->
        {:ok, unexpected_response}
      end)

      conn =
        post(conn, ~p"/private/login", %{
          "auth_type" => "oauth",
          "org_id" => Base.encode64(user.sub_org_id),
          "stamped_body" => "unexpected_body",
          "stamp" => "unexpected_stamp"
        })

      response = json_response(conn, 200)
      # Should fallback to JSON encoding of entire response
      assert %{"jwt" => jwt} = response
      assert is_binary(jwt)
      decoded_jwt = Jason.decode!(jwt)
      assert decoded_jwt == unexpected_response
    end

    test "supports both passkey and oauth auth types with same user", %{conn: conn} do
      user = insert(:user, %{sub_org_id: "multi_auth_org"})

      # Test passkey first
      passkey_response = %{
        "activity" => %{
          "result" => %{
            "activity" => %{
              "result" => %{
                "stampLoginResult" => %{
                  "session" => "passkey_session"
                }
              }
            }
          }
        }
      }

      stub(Mock, :build_payload, fn _method, _url, _headers, _body ->
        %{method: :post, url: "test", headers: [], body: ""}
      end)

      stub(Mock, :request, fn _payload ->
        {:ok, passkey_response}
      end)

      conn1 =
        post(conn, ~p"/private/login", %{
          "auth_type" => "passkey",
          "org_id" => Base.encode64(user.sub_org_id),
          "stamped_body" => "passkey_body",
          "stamp" => "passkey_stamp"
        })

      assert %{"jwt" => "passkey_session"} = json_response(conn1, 200)

      # Test OAuth with same user
      oauth_response = %{
        "activity" => %{
          "result" => %{
            "activity" => %{
              "result" => %{
                "oauthLoginResult" => %{
                  "session" => "oauth_session"
                }
              }
            }
          }
        }
      }

      stub(Mock, :request, fn _payload ->
        {:ok, oauth_response}
      end)

      conn2 =
        post(conn, ~p"/private/login", %{
          "auth_type" => "oauth",
          "org_id" => Base.encode64(user.sub_org_id),
          "stamped_body" => "oauth_body",
          "stamp" => "oauth_stamp"
        })

      assert %{"jwt" => "oauth_session"} = json_response(conn2, 200)
    end
  end
end
